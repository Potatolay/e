
--local hat = game:GetService("Workspace")[game.Players.LocalPlayer.Name]["White SS"]

--gh 6904794619
Mode = "Permadeath"
HumanDied = false
game.Players.LocalPlayer.Character.HumanoidRootPart.Transparency = 0.6

Countsyntax = 1
function syntax(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..Countsyntax
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..Countsyntax
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 67752;
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..Countsyntax
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..Countsyntax
	local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..Countsyntax
	local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..Countsyntax
	AttachmentC.Orientation = Angle
	AttachmentA.Position = Position
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentC;
	AlignOri.Attachment0 = AttachmentD;
	Countsyntax = Countsyntax + 1

end

coroutine.wrap(function()
	local player = game.Players.LocalPlayer
	local char = player.Character or player.CharacterAdded:wait()
	if sethiddenproperty then
		while true do
			game:GetService("RunService").RenderStepped:Wait()
			settings().Physics.AllowSleep = false
			local TBL = game:GetService("Players"):GetChildren() 
			for _ = 1,#TBL do local Players = TBL[_]
				if Players ~= game:GetService("Players").LocalPlayer then
					Players.MaximumSimulationRadius = 0
					sethiddenproperty(Players,"SimulationRadius",0) 
				end 
			end
			game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
			sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.pow(math.huge,math.huge)*math.huge)
			if HumanDied then break end
		end
	else
		while true do
			game:GetService("RunService").RenderStepped:Wait()
			settings().Physics.AllowSleep = false
			local TBL = game:GetService("Players"):GetChildren() 
			for _ = 1,#TBL do local Players = TBL[_]
				if Players ~= game:GetService("Players").LocalPlayer then
					Players.MaximumSimulationRadius = 0
				end 
			end
			game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
			if HumanDied then break end
		end
	end
end)()

if game:GetService("Players").LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
	if Mode == "Permadeath" then --------------------------------------------------------------------------------------------------------------------
		game:GetService("Players").LocalPlayer["Character"].Archivable = true 
		local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
		local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
		Instance.new("Part",FalseChar).Name = "Head" 
		Instance.new("Part",FalseChar).Name = "Torso" 
		Instance.new("Humanoid",FalseChar).Name = "Humanoid"
		game:GetService("Players").LocalPlayer["Character"] = FalseChar
		game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
		local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
		Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
		Clone.Name = "Humanoid"
		game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
		game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
		game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
		game.Players.LocalPlayer.Character.Humanoid.HipHeight = 5		
		wait(5.65)
		game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
		CloneChar.Parent = workspace 
		CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,15,0)

		CloneChar.Humanoid.BreakJointsOnDeath = false
		workspace.Camera.CameraSubject = CloneChar.Humanoid 
		CloneChar.Name = "Dummy" 
		CloneChar.Humanoid.DisplayDistanceType = "None"

		FalseChar:Destroy()

		local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

		local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
		local CONVEC
		local function VECTORUNIT()
			if HumanDied then CONVEC:Disconnect(); return end
			local lookVec = workspace.Camera.CFrame.lookVector
			local Root = CloneChar["HumanoidRootPart"]
			LVecPart.Position = Root.Position
			LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
		end
		CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

		local CONDOWN
		local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
		local function KEYDOWN(_,Processed) 
			if HumanDied then CONDOWN:Disconnect(); return end
			if Processed ~= true then
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = true end
				if Key == Enum.KeyCode.A then
					ADown = true end
				if Key == Enum.KeyCode.S then
					SDown = true end
				if Key == Enum.KeyCode.D then
					DDown = true end
				if Key == Enum.KeyCode.Space then
					SpaceDown = true end end end
		CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

		local CONUP
		local function KEYUP(_)
			if HumanDied then CONUP:Disconnect(); return end
			local Key = _.KeyCode
			if Key == Enum.KeyCode.W then
				WDown = false end
			if Key == Enum.KeyCode.A then
				ADown = false end
			if Key == Enum.KeyCode.S then
				SDown = false end
			if Key == Enum.KeyCode.D then
				DDown = false end
			if Key == Enum.KeyCode.Space then
				SpaceDown = false end end
		CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

		local function MoveClone(X,Y,Z)
			LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
			workspace["Dummy"].Humanoid.WalkToPoint = LVecPart.Position
		end

		coroutine.wrap(function() 
			while true do game:GetService("RunService").RenderStepped:Wait()
				if HumanDied then break end
				if WDown then MoveClone(0,0,1e4) end
				if ADown then MoveClone(1e4,0,0) end
				if SDown then MoveClone(0,0,-1e4) end
				if DDown then MoveClone(-1e4,0,0) end
				if SpaceDown then CloneChar["Humanoid"].Jump = true end
				if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
					workspace["Dummy"].Humanoid.WalkToPoint = workspace["Dummy"].HumanoidRootPart.Position end
			end 
		end)()

		local con
		function UnCollide()
			if HumanDied then con:Disconnect(); return end
			for _,Parts in next, CloneChar:GetDescendants() do
				if Parts:IsA("BasePart") then
					Parts.CanCollide = false 
				end 
			end
			for _,Parts in next, DeadChar:GetDescendants() do
				if Parts:IsA("BasePart") then
					Parts.CanCollide = false
				end 
			end 
		end
		con = game:GetService("RunService").Stepped:Connect(UnCollide)

		local resetBindable = Instance.new("BindableEvent")
		resetBindable.Event:connect(function()
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
			resetBindable:Destroy()
			CloneChar.Humanoid.Health = 0
		end)
		game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)
		game.Players.LocalPlayer.Character.HumanoidRootPart.Size = Vector3.new(1,1,1)
		game.Players.LocalPlayer.Character.HumanoidRootPart.Transparency = 0.3
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
					HumanDied = true
					pcall(function()
						game.Players.LocalPlayer.Character = CloneChar
						CloneChar:Destroy()
						game.Players.LocalPlayer.Character = DeadChar
						if resetBindable then
							game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
							resetBindable:Destroy()
						end
						DeadChar.Humanoid.Health = 0
					end)
					break
				end		
			end
		end)()

		syntax(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		syntax(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		syntax(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		syntax(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		syntax(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		syntax(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		syntax(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

		for _,v in next, DeadChar:GetChildren() do
			if v:IsA("Accessory") then
				if v.Name == "PlainTail" then
					Tail = CloneChar[v.Name].Handle
				end
				syntax(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end

		for _,BodyParts in next, CloneChar:GetDescendants() do
			if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
				BodyParts.Transparency = 1 end end
	end
end

local CloneChar = workspace.Dummy



for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") then--and v.Name ~="HumanoidRootPart" then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(0,-25.05,0)
			wait(0.5)
		end)
	end
end



function RUNANIMATESCRIPT(FOLDER)

	local Figure = FOLDER.Parent
	local Torso = Figure:WaitForChild("Torso")
	local RightShoulder = Torso:WaitForChild("Right Shoulder")
	local LeftShoulder = Torso:WaitForChild("Left Shoulder")
	local RightHip = Torso:WaitForChild("Right Hip")
	local LeftHip = Torso:WaitForChild("Left Hip")
	local Neck = Torso:WaitForChild("Neck")
	local Humanoid = Figure:WaitForChild("Humanoid")
	local pose = "Standing"

	local currentAnim = ""
	local currentAnimInstance = nil
	local currentAnimTrack = nil
	local currentAnimKeyframeHandler = nil
	local currentAnimSpeed = 1.0
	local animTable = {}
	local animNames = { 
		idle = 	{	
			{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
			{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
		},
		walk = 	{ 	
			{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
		}, 
		run = 	{
			{ id = "run.xml", weight = 10 } 
		}, 
		jump = 	{
			{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
		}, 
		fall = 	{
			{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
		}, 
		climb = {
			{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
		}, 
		sit = 	{
			{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
		},	
		toolnone = {
			{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
		},
		toolslash = {
			{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
			--				{ id = "slash.xml", weight = 10 } 
		},
		toollunge = {
			{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
		},
		wave = {
			{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
		},
		point = {
			{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
		},
		dance1 = {
			{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
		},
		dance2 = {
			{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
		},
		dance3 = {
			{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
			{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
		},
		laugh = {
			{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
		},
		cheer = {
			{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
		},
	}
	local dances = {"dance1", "dance2", "dance3"}

	-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
	local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

	function configureAnimationSet(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}

		-- check for config values
		local config = FOLDER:FindFirstChild(name)
		if (config ~= nil) then
			--		print("Loading anims " .. name)
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			local idx = 1
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject == nil) then
						animTable[name][idx].weight = 1
					else
						animTable[name][idx].weight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
					--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
					idx = idx + 1
				end
			end
		end

		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
				--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
			end
		end
	end

	-- Setup animation objects
	function scriptChildModified(child)
		local fileList = animNames[child.Name]
		if (fileList ~= nil) then
			configureAnimationSet(child.Name, fileList)
		end	
	end

	FOLDER.ChildAdded:connect(scriptChildModified)
	FOLDER.ChildRemoved:connect(scriptChildModified)


	for name, fileList in pairs(animNames) do 
		configureAnimationSet(name, fileList)
	end	

	-- ANIMATION

	-- declarations
	local toolAnim = "None"
	local toolAnimTime = 0

	local jumpAnimTime = 0
	local jumpAnimDuration = 0.3

	local toolTransitionTime = 0.1
	local fallTransitionTime = 0.3
	local jumpMaxLimbVelocity = 0.75

	-- functions

	function stopAllAnimations()
		local oldAnim = currentAnim

		-- return to idle if finishing an emote
		if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
			oldAnim = "idle"
		end

		currentAnim = ""
		currentAnimInstance = nil
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end

		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop()
			currentAnimTrack:Destroy()
			currentAnimTrack = nil
		end
		return oldAnim
	end

	function setAnimationSpeed(speed)
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end

	function keyFrameReachedFunc(frameName)
		if (frameName == "End") then

			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end

			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.0, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end

	-- Preload animations
	function playAnimation(animName, transitionTime, humanoid) 

		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
		--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		-- switch animation		
		if (anim ~= currentAnimInstance) then

			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop(transitionTime)
				currentAnimTrack:Destroy()
			end

			currentAnimSpeed = 1.0

			-- load it to the humanoid; get AnimationTrack
			currentAnimTrack = humanoid:LoadAnimation(anim)
			currentAnimTrack.Priority = Enum.AnimationPriority.Core

			-- play the animation
			currentAnimTrack:Play(transitionTime)
			currentAnim = animName
			currentAnimInstance = anim

			-- set up keyframe name triggers
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end
			currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)

		end

	end

	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------

	local toolAnimName = ""
	local toolAnimTrack = nil
	local toolAnimInstance = nil
	local currentToolAnimKeyframeHandler = nil

	function toolKeyFrameReachedFunc(frameName)
		if (frameName == "End") then
			--		print("Keyframe : ".. frameName)	
			playToolAnimation(toolAnimName, 0.0, Humanoid)
		end
	end


	function playToolAnimation(animName, transitionTime, humanoid, priority)	 

		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
		--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then

			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end

			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end

			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
	end

	function stopToolAnimations()
		local oldAnim = toolAnimName

		if (currentToolAnimKeyframeHandler ~= nil) then
			currentToolAnimKeyframeHandler:disconnect()
		end

		toolAnimName = ""
		toolAnimInstance = nil
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			toolAnimTrack = nil
		end


		return oldAnim
	end

	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------


	function onRunning(speed)
		if speed > 0.01 then
			playAnimation("walk", 0.1, Humanoid)
			if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
				setAnimationSpeed(speed / 14.5)
			end
			pose = "Running"
		else
			if emoteNames[currentAnim] == nil then
				playAnimation("idle", 0.1, Humanoid)
				pose = "Standing"
			end
		end
	end

	function onDied()
		pose = "Dead"
	end

	function onJumping()
		playAnimation("jump", 0.1, Humanoid)
		jumpAnimTime = jumpAnimDuration
		pose = "Jumping"
	end

	function onClimbing(speed)
		playAnimation("climb", 0.1, Humanoid)
		setAnimationSpeed(speed / 12.0)
		pose = "Climbing"
	end

	function onGettingUp()
		pose = "GettingUp"
	end

	function onFreeFall()
		if (jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		end
		pose = "FreeFall"
	end

	function onFallingDown()
		pose = "FallingDown"
	end

	function onSeated()
		pose = "Seated"
	end

	function onPlatformStanding()
		pose = "PlatformStanding"
	end

	function onSwimming(speed)
		if speed > 0 then
			pose = "Running"
		else
			pose = "Standing"
		end
	end

	function getTool()	
		for _, kid in ipairs(Figure:GetChildren()) do
			if kid.className == "Tool" then return kid end
		end
		return nil
	end

	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end

	function animateTool()

		if (toolAnim == "None") then
			playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
			return
		end

		if (toolAnim == "Slash") then
			playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end

		if (toolAnim == "Lunge") then
			playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	end

	function moveSit()
		RightShoulder.MaxVelocity = 0.15
		LeftShoulder.MaxVelocity = 0.15
		RightShoulder:SetDesiredAngle(3.14 /2)
		LeftShoulder:SetDesiredAngle(-3.14 /2)
		RightHip:SetDesiredAngle(3.14 /2)
		LeftHip:SetDesiredAngle(-3.14 /2)
	end

	local lastTick = 0

	function move(time)
		local amplitude = 1
		local frequency = 1
		local deltaTime = time - lastTick
		lastTick = time

		local climbFudge = 0
		local setAngles = false

		if (jumpAnimTime > 0) then
			jumpAnimTime = jumpAnimTime - deltaTime
		end

		if (pose == "FreeFall" and jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		elseif (pose == "Seated") then
			playAnimation("sit", 0.5, Humanoid)
			return
		elseif (pose == "Running") then
			playAnimation("walk", 0.1, Humanoid)
		elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
			--		print("Wha " .. pose)
			stopAllAnimations()
			amplitude = 0.1
			frequency = 1
			setAngles = true
		end

		if (setAngles) then
			local desiredAngle = amplitude * math.sin(time * frequency)

			RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
			LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
			RightHip:SetDesiredAngle(-desiredAngle)
			LeftHip:SetDesiredAngle(-desiredAngle)
		end

		-- Tool Animation handling
		local tool = getTool()
		if tool and tool:FindFirstChild("Handle") then

			local animStringValueObject = getToolAnim(tool)

			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = time + .3
			end

			if time > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end

			animateTool()		
		else
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end


	local events = {}
	local eventHum = Humanoid

	local function onUnhook()
		for i = 1, #events do
			events[i]:Disconnect()
		end
		events = {}
	end

	local function onHook()
		onUnhook()

		pose = eventHum.Sit and "Seated" or "Standing"

		events = {
			eventHum.Died:connect(onDied),
			eventHum.Running:connect(onRunning),
			eventHum.Jumping:connect(onJumping),
			eventHum.Climbing:connect(onClimbing),
			eventHum.GettingUp:connect(onGettingUp),
			eventHum.FreeFalling:connect(onFreeFall),
			eventHum.FallingDown:connect(onFallingDown),
			eventHum.Seated:connect(onSeated),
			eventHum.PlatformStanding:connect(onPlatformStanding),
			eventHum.Swimming:connect(onSwimming)
		}
	end


	onHook()
	--FOLDER:WaitForChild("Loaded").Value = true


	-- main program

	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"

	spawn(function()
		while Figure.Parent ~= nil do
			local _, time = wait(0.1)
			move(time)
		end
	end)

	return {
		onRunning = onRunning, 
		onDied = onDied, 
		onJumping = onJumping, 
		onClimbing = onClimbing, 
		onGettingUp = onGettingUp, 
		onFreeFall = onFreeFall, 
		onFallingDown = onFallingDown, 
		onSeated = onSeated, 
		onPlatformStanding = onPlatformStanding,
		onHook = onHook,
		onUnhook = onUnhook
	}

end
RUNANIMATESCRIPT(CloneChar.Animate)

local IsDead = false
local StateMover = true

local playerss = workspace.Dummy
local bbv,bullet
if Mode == "Permadeath" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Transparency = (FlingBlockInvisible ~= true and 0 or 1)
	bullet.Massless = true
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end

	bbv = Instance.new("BodyPosition",bullet)
	bbv.Position = playerss.HumanoidRootPart.CFrame.p
end

if Mode == "Permadeath" then
	coroutine.wrap(function()
		while true do
			if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
			if StateMover then
				bbv.Position = playerss.HumanoidRootPart.CFrame.p
				bullet.Position = playerss["Right Arm"].CFrame.p
				--here for hat - bullet.Position = hat.Handle.Position
			end
			game:GetService("RunService").RenderStepped:wait()
		end
	end)()
end

local runservice=game:service"RunService";
local player=game:service"Players"["LocalPlayer"];
local character=player["Character"];
local blacklisted="Right Arm Left Arm Right Leg Left Leg Torso Head";
local limbs={};
character.HumanoidRootPart.Transparency = 0.6
for i,v in next,character:children() do
	if (v.ClassName=="Part") and not blacklisted:find(v.Name) then
		local outline = Instance.new("SelectionBox")
		outline.Name = "Outline"
		outline.Color3 = Color3.new(2550,0,0)
		outline.SurfaceColor3 = Color3.new(0, 1, 0)
		--outline.SurfaceTransparency = 0.9
		outline.LineThickness = 0.08
		outline.Transparency = 0.3
		outline.Adornee = v
		outline.Parent = v
		limbs[v.Name]=v;
	end
end

bbav = Instance.new("BodyAngularVelocity",bullet)
bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
bbav.P = 100000000000000000000000000000
bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)

local CDDF = {}
local DamageFling = function(DmgPer)
	if Fling ~= true then return end
	if IsDead or Mode ~= "Permadeath" or (DmgPer.Name == playerss.Name and DmgPer.Name == "Dummy") or CDDF[DmgPer] or not DmgPer or not DmgPer:FindFirstChildOfClass("Humanoid") or DmgPer:FindFirstChildOfClass("Humanoid").Health <= 0 then return end
	CDDF[DmgPer] = true; StateMover = false
	local PosFling = (DmgPer:FindFirstChild("HumanoidRootPart") and DmgPer:FindFirstChild("HumanoidRootPart") .CFrame.p) or (DmgPer:FindFirstChildOfClass("Part") and DmgPer:FindFirstChildOfClass("Part").CFrame.p)
	bullet.Rotation = playerss.HumanoidRootPart.Rotation
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 100000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)

	for _=1,15 do
		bbv.Position = PosFling
		bullet.Position = PosFling
		wait(0.03)
	end
	bbav:Destroy()
	bbv.Position = playerss.HumanoidRootPart.CFrame.p
	bullet.Position = playerss.HumanoidRootPart.CFrame.p
	CDDF[DmgPer] = false; StateMover = true
end

wait(.2)


local Aligns = 0
function Align(Part0,Part1,Position,Rotation)
	Aligns = Aligns + 1
	local a0,a1 = Instance.new("Attachment",Part0), Instance.new("Attachment",Part1)
	a1.Position = Position or Vector3.new()
	a1.Rotation = Rotation or Vector3.new()
	local ap = Instance.new("AlignPosition", Part0)
	ap.Attachment0 = a0
	ap.Attachment1 = a1
	local ao = Instance.new("AlignOrientation", Part0)
	ao.Name = "AO-"..Aligns
	ap.Name = "AP-"..Aligns
	ao.Attachment0 = a0
	ao.Attachment1 = a1
	ap.ApplyAtCenterOfMass = true;
	ap.MaxForce = 67752;
	ap.MaxVelocity = math.huge/9e110;
	ap.ReactionForceEnabled = false;
	ap.Responsiveness = 200;
	ap.RigidityEnabled = false;
	ao.MaxAngularVelocity = math.huge/9e110;
	ao.MaxTorque = 67752;
	ao.PrimaryAxisOnly = false;
	ao.ReactionTorqueEnabled = false;
	ao.Responsiveness = 200;
	ao.RigidityEnabled = false;
	return a1
end

local HumanoidIsDead = false

for i,f in pairs(game.workspace.Dummy.Head:GetChildren()) do
	if f:IsA("Decal") and f.Name == "face" then
		f.Parent = nil
	end

end



local c = game.Players.LocalPlayer.Character

local s,e = pcall(function()
	char1 = game.Players.LocalPlayer.Character
	plr = game.Players.LocalPlayer
	char = game.Players.LocalPlayer.Character
	mouse = plr:GetMouse()
	bullet = char["HumanoidRootPart"]
	-- bullet.Handle.Transparency = 1


	_G.Shooting = false



	pew = false


	TweenService = game:GetService("TweenService")
	coroutine.resume(coroutine.create(function()
		while true do
			wait()
			if pew then

				wait()
				local tweenInfo = TweenInfo.new(0.1)

				local tween = TweenService:Create(bullet, tweenInfo, {CFrame = CFrame.new(mouse.Hit.p)})

				tween:Play()
				wait(0.1)
				bullet.CFrame =  c["Right Arm"].CFrame + Vector3.new(0,-2,0)   
			else
				bullet.CFrame = c["Right Arm"].CFrame + Vector3.new(0,-2,0)   

			end

		end
	end))
end)





local Player=game.Players.LocalPlayer local Character=workspace.Dummy local hum = Character.Humanoid local LeftArm=Character["Left Arm"] local LeftLeg=Character["Left Leg"] local RightArm=Character["Right Arm"] local RightLeg=Character["Right Leg"] local Root=Character["HumanoidRootPart"] local Head=Character["Head"] local Torso=Character["Torso"] local Neck=Torso["Neck"] local mouse = Player:GetMouse() local position = nil local sine = 0 local t = 0 local change = 1

soundcharacter = Instance.new("Sound", Character)
soundcharacter.Volume = 1
soundcharacter.Name = "Void"
soundcharacter.Looped = true
soundcharacter.SoundId = ""
soundcharacter:Play()

local HBill = Instance.new("BillboardGui", Head)
local HMain, HBarBack, HBar = Instance.new("Frame", HBill), Instance.new("Frame"), Instance.new("Frame")
local HName = Instance.new("TextLabel")
HBill.Size = UDim2.new(15,0,2.2,0)
HBill.Name = "xd"
HBill.StudsOffset = Vector3.new(0,3,0)
HBill.AlwaysOnTop = true
HBill.Enabled=true
HMain.BackgroundColor3 = Color3.new(0, 0, 0)
HMain.BackgroundTransparency = 1
HMain.Size = UDim2.new(1,0,1,0)


HName.Parent = HMain
HName.BackgroundTransparency = 1
HName.Size = UDim2.new(1,0,.6,0)
HName.Font = "Bangers"
HName.Text = ""
HName.TextScaled = true
HName.TextColor3 = Color3.fromRGB(0, 0, 0)
HName.TextStrokeColor3 = Color3.new(255, 255, 255)
HName.TextStrokeTransparency = 0
HName.TextYAlignment = "Top"

local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local TORSOLERP = Instance.new("ManualWeld")
TORSOLERP.Parent = Root
TORSOLERP.Part0 = Torso
TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local ROOTLERP = Instance.new("ManualWeld")
ROOTLERP.Parent = Root
ROOTLERP.Part0 = Root
ROOTLERP.Part1 = Torso
ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTARMLERP = Instance.new("ManualWeld")
RIGHTARMLERP.Parent = RightArm
RIGHTARMLERP.Part0 = RightArm
RIGHTARMLERP.Part1 = Torso
RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTARMLERP = Instance.new("ManualWeld")
LEFTARMLERP.Parent = LeftArm
LEFTARMLERP.Part0 = LeftArm
LEFTARMLERP.Part1 = Torso
LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTLEGLERP = Instance.new("ManualWeld")
RIGHTLEGLERP.Parent = RightLeg
RIGHTLEGLERP.Part0 = RightLeg
RIGHTLEGLERP.Part1 = Torso
RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTLEGLERP = Instance.new("ManualWeld")
LEFTLEGLERP.Parent = LeftLeg
LEFTLEGLERP.Part0 = LeftLeg
LEFTLEGLERP.Part1 = Torso
LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end

m = game.Players.LocalPlayer:GetMouse()

attack = false
idle = true

toggle = false






local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local TORSOLERP = Instance.new("ManualWeld")
TORSOLERP.Parent = Root
TORSOLERP.Part0 = Torso
TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local ROOTLERP = Instance.new("ManualWeld")
ROOTLERP.Parent = Root
ROOTLERP.Part0 = Root
ROOTLERP.Part1 = Torso
ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTARMLERP = Instance.new("ManualWeld")
RIGHTARMLERP.Parent = RightArm
RIGHTARMLERP.Part0 = RightArm
RIGHTARMLERP.Part1 = Torso
RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTARMLERP = Instance.new("ManualWeld")
LEFTARMLERP.Parent = LeftArm
LEFTARMLERP.Part0 = LeftArm
LEFTARMLERP.Part1 = Torso
LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTLEGLERP = Instance.new("ManualWeld")
RIGHTLEGLERP.Parent = RightLeg
RIGHTLEGLERP.Part0 = RightLeg
RIGHTLEGLERP.Part1 = Torso
RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTLEGLERP = Instance.new("ManualWeld")
LEFTLEGLERP.Parent = LeftLeg
LEFTLEGLERP.Part0 = LeftLeg
LEFTLEGLERP.Part1 = Torso
LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end

m = game.Players.LocalPlayer:GetMouse()

attack = false
idle = true

toggle = false






local objects = game:GetObjects("rbxassetid://5813708464")
objects[1].Parent = game.Players.LocalPlayer.Character
local script = game.Players.LocalPlayer.Character.MainModule.Lunatic
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = workspace.Dummy
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor


Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local neck2 = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
--ROBLOXIDLEANIMATION.Parent = Humanoid
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
ANIMATOR:Destroy()
local UNANCHOR = true
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}	
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)


function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function Clerp(a, b, t)
    return a:lerp(b,t)
end



function weld(parent, part0, part1, c0, c1)
	local w = IT("Weld")
	w.Part0 = part0
	w.Part1 = part1
	w.C0 = c0
	w.C1 = c1
	w.Parent = parent
	return w
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.EmitterSize = 5*VOLUME
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

function WACKYEFFECT2(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLORLOOP = (Table.ColorLoop or false)
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					if COLORLOOP == true then
					EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					if COLORLOOP == true then
						EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end


function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						local CAMSHAKER = script.CamShake:Clone()
						CAMSHAKER.Shake.Value = INTENSITY
						CAMSHAKER.Timer.Value = TIME
						CAMSHAKER.Parent = CHILD
						CAMSHAKER.Disabled = false
					end
				end
			end
		end
	end
end


function AttachmentCFrame(What)
	return What.Parent.CFrame*CF(What.Position)
end


--weap
local SONG = 423410746
d = CF(0,0,0)
local la = IT("Weld")
local ra = IT("Weld")
RightShoulder.Parent = nil
LeftShoulder.Parent = nil
ra.Name = "ra"
ra.Part0 = Torso 
ra.C0 = CF(1.5, 0.5, 0)
ra.C1 = CF(0, 0.5, 0)
ra.Part1 = RightArm
ra.Parent = Torso  

la.Name = "la"
la.Part0 = Torso 
la.C0 = CF(-1.5, 0.5, 0)
la.C1 = CF(0, 0.5, 0) 
la.Part1 = LeftArm
la.Parent = Torso

local lh = weld(LeftLeg,Torso,LeftLeg,CF(-.5,-1,0),d)
lh.C1 = CF(0,1,0)
local rh = weld(RightLeg,Torso,RightLeg,CF(.5,-1,0),d)
rh.C1 = CF(0,1,0)

local luneye = script.LunaticEyeModel
local lunw = weld(luneye.Main,luneye.Main,Torso,CF(0,-2,0),d) lunw.Name = "mainweld"
local lunw2 = luneye.Main.www
luneye.Parent = Character
for g,h in pairs(luneye:GetChildren()) do h.Anchored = false end

player = game:GetService("Players").LocalPlayer
character = game.Workspace.Dummy
dummy = game.Workspace.Dummy.LunaticEyeModel
item = character["Vector Arrow"].Handle -- change to your hat name
item:BreakJoints()


alignOr = Instance.new("AlignOrientation",character["Head"])
alignPosition = Instance.new("AlignPosition",character["Head"])
a0 = Instance.new("Attachment",item)
a1 = Instance.new("Attachment",dummy["Eye"]) -- change to where you want your hat
alignPosition.Attachment0 = a0
alignPosition.Attachment1 = a1
alignPosition.Responsiveness = 99e9
alignPosition.RigidityEnabled = true
alignOr.Attachment0 = a0
alignOr.Attachment1 = a1
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = math.huge
alignOr.RigidityEnabled = false

a0.Position = Vector3.new(1, -0.5, 0) -- change this
a0.Orientation = Vector3.new(0,0,0) -- and this to your choice

player = game:GetService("Players").LocalPlayer
character = game.Workspace.Dummy
dummy = game.Workspace.Dummy.LunaticEyeModel
item = character["Nebula Blade"].Handle -- change to your hat name
item:BreakJoints()


alignOr = Instance.new("AlignOrientation",character["Head"])
alignPosition = Instance.new("AlignPosition",character["Head"])
a0 = Instance.new("Attachment",item)
a1 = Instance.new("Attachment",dummy["Eye"]) -- change to where you want your hat
alignPosition.Attachment0 = a0
alignPosition.Attachment1 = a1
alignPosition.Responsiveness = 99e9
alignPosition.RigidityEnabled = true
alignOr.Attachment0 = a0
alignOr.Attachment1 = a1
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = math.huge
alignOr.RigidityEnabled = false

a0.Position = Vector3.new(0, 0, 0) -- change this
a0.Orientation = Vector3.new(0,0,0) -- and this to your choice


--dmg
function da(MODEL)
	for index, CHILD in pairs(MODEL:GetChildren()) do
		coroutine.resume(coroutine.create(function()
		swait(MRANDOM(8,12)/10)
		if CHILD:IsA("BasePart") and CHILD.Name ~= "HumanoidRootPart" then
			if CHILD.Name == "Head" then
					WACKYEFFECT2({Time = 60, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = VT(0,0,0), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame*CF(MRANDOM(-4,4),MRANDOM(-4,4),MRANDOM(-4,4)), MoveToPos = CHILD.Position, RotationX = MRANDOM(-4,4), RotationY = MRANDOM(-4,4), RotationZ = MRANDOM(-4,4), Material = "Neon", Color = scol, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, SizeBoomerang = 0, Boomerang = 35})
				elseif CHILD.Name ~= "HumanoidRootPart" then
					WACKYEFFECT2({Time = 60, EffectType = "Box", Size = CHILD.Size, Size2 = VT(0,0,0), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame*CF(MRANDOM(-4,4),MRANDOM(-4,4),MRANDOM(-4,4)), MoveToPos = CHILD.Position, RotationX = MRANDOM(-4,4), RotationY = MRANDOM(-4,4), RotationZ = MRANDOM(-4,4) ,Material = "Neon", Color = scol, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, SizeBoomerang = 0, Boomerang = 35})
				end
			CHILD:remove()
		end
		end))
		end
	Debris:AddItem(MODEL,6)
end

function ApplyDamage(Humanoid,Damage)
	Damage = Damage
	if Humanoid.Health < 111111110 then
		if Humanoid.Health - Damage > 111111110 then
		else
		end
	else
	end
end

function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			if HUM then
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							da(CHILD)
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

--attacks
function cs()
if SONG == 423410746 then
SONG = 4260724907
elseif SONG == 4260724907 then
SONG = 1367698276
elseif SONG == 1367698276 then
SONG = 4507611539
elseif SONG == 4507611539 then
SONG = 423410746
end
end

function lproj()
	ATTACK = true
	for i = 0,27*2 do
		Swait()
	local Alpha = .1
	spinspeed = 10
	loopval2 = 30
	if MRANDOM(1,2) == 1 then
	WACKYEFFECT2({Time = 30, EffectType = "Box", Size = VT(1.5,1.5,0), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = luneye.CenterPart.CFrame*CF(MRANDOM(-10,10),MRANDOM(-10,10),0), MoveToPos = luneye.CenterPart.Position, RotationX = 0, RotationY = MRANDOM(-5,5), RotationZ = 0, Material = "Neon", Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	WACKYEFFECT2({Time = 60, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(8+1*COS(SINE/6),8+1*COS(SINE/6),.1), Transparency = .5, Transparency2 = 1, CFrame = luneye.CenterPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
	lunw.C1 = lunw.C1:lerp(CF(3,0,-5)*ANGLES(RAD(-8.9),RAD(-37.8),0),.2)
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.1,0.1)*ANGLES(RAD(8.9),RAD(38.4),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-0.9,-0.1)*ANGLES(RAD(-5.9),RAD(7.2),RAD(-8.8)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,-0.1)*ANGLES(RAD(-7.2),RAD(-7.2),RAD(-1.8)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.4,0.3,-0.3)*ANGLES(RAD(80.9),RAD(-4.2),RAD(39.7)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(-0.2,0,0.2)*ANGLES(RAD(-11.5),RAD(-37.8),RAD(-7.1))*NECKC0,Alpha)
	end
	local sph = CreatePart(3,Effects,"Neon",0,0,"Deep blue","HI IM ELIZA",VT(5,5,5),true)
	MakeForm(sph,"Ball")
	sph.CFrame = RightArm.CFrame*CF(0,-1,0)
	CreateSound(206083325,RightArm,5,1,false)
	local done = false
	spawn(function()
	repeat Swait()
	WACKYEFFECT2({Time = 45, EffectType = "Box", Size = VT(1.2,1.2,1.2)*1.4, Size2 = VT(0,0,0), Transparency = 0, Transparency2 = .3, CFrame = sph.CFrame*CF(MRANDOM(-2,2),MRANDOM(-2,2),MRANDOM(-2,2))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))+SINE*4,RAD(MRANDOM(-360,360))), MoveToPos = sph.Position, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	until done == true
	end)
	coroutine.resume(coroutine.create(function()
	sph.CFrame = CF(sph.Position,Mouse.Hit.p)
	for i = 1,250 do
	Swait()
	sph.CFrame = sph.CFrame*CF(0,0,-3)
	local hit,pos = Raycast(sph.Position,sph.CFrame.lookVector,5,Character)
	if hit then break end
	end
	WACKYEFFECT2({Time = 55, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(20,20,20)*2.3, Transparency = 0, Transparency2 = 1, CFrame = sph.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = scol,SoundID = 3570964678, SoundPitch = .7, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 10})
	for i = 1,4 do
	WACKYEFFECT2({Time = 65, EffectType = "Box", Size = VT(1,1,1), Size2 = VT(45,45,45), Transparency = 0, Transparency2 = 1, CFrame = sph.CFrame*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = MRANDOM(-3,3), RotationY = MRANDOM(-3,3), RotationZ = MRANDOM(-3,3), Material = "Neon", Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
	for i = 1,10 do
	WACKYEFFECT2({Time = 60, EffectType = "Box", Size = VT(3,3,0)*5, Size2 = VT(2,2,0), Transparency = 0, Transparency2 = 1, CFrame = sph.CFrame, MoveToPos = sph.Position+VT(MRANDOM(-28,28),MRANDOM(0,28),MRANDOM(-28,28))*2, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Neon", Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
	for i = 1,3 do
	WACKYEFFECT2({Time = 60, EffectType = "Ring", Size = VT(0,0,0), Size2 = VT(30,30,15)/5, Transparency = 0, Transparency2 = 1, CFrame = sph.CFrame*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = MRANDOM(-1,1), RotationY = MRANDOM(-1,1), RotationZ = MRANDOM(-1,1), Material = "Neon", Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
	ApplyAoE(sph.Position,20,0,0,75,true)
	sph:Destroy()
	done = true	
	end))
	spinspeed = 1.8
	ATTACK = false
end

function arcs()
	ATTACK = true
	for i = 0,20 do
		Swait()
		  	local Alpha = .1
	lunw.C1 = lunw.C1:lerp(CF(0,0,-4)*ANGLES(RAD(-90),RAD(0),0),.2)
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,-0.1)*ANGLES(RAD(0),RAD(40.9),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,-0.1)*ANGLES(RAD(0.4),RAD(7),RAD(-3.3)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,-0.1)*ANGLES(RAD(0.5),RAD(-7.5),RAD(3.8)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.3,0.5,0.2)*ANGLES(RAD(4.6),RAD(20.9),RAD(-12.6)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(0.6,0.2,-0.8)*ANGLES(RAD(87.1),RAD(0),RAD(-77.7)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(-0.1,0,0.1)*ANGLES(RAD(0),RAD(-40.9),RAD(0))*NECKC0,Alpha)
	end
	local lunc = luneye:Clone()
	lunc.Name = "fakeluneye"
	lunc.Main.mainweld:Destroy()
	lunc.Main.Anchored = true
	--for j,e in pairs(lunc:GetChildren()) do if e:IsA("BasePart") then e.Anchored=true end end
	lunc.Parent = Character
	luneye.Parent = nil
	lunc.Main.CFrame = RightArm.CFrame*CF(0,-1,0)
	coroutine.resume(coroutine.create(function()
		--luneye.CFrame = CF(luneye.CFrame)
	
		CreateSound(1428541279,RightArm,5,1,false)
	for i = 1,15 do
		Swait()
		lunc.Main.CFrame = lunc.Main.CFrame:lerp(CF(Mouse.Hit.p)*ANGLES(RAD(-90),0,0),.08)
	end
	local hit,pos = Raycast(lunc.Main.Position,lunc.Main.CFrame.lookVector,5,Character)
	WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(15,40,15)/5, Size2 = VT(15,40,15)*2.4, Transparency = 0, Transparency2 = 1, CFrame = CF(pos), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = scol,SoundID = 192410077, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(15,40,15)/5, Size2 = VT(15,40,15)*1.8, Transparency = 0, Transparency2 = 1, CFrame = CF(pos), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	WACKYEFFECT2({Time = 40, EffectType = "Box", Size = VT(30,30,30)/1.5, Size2 = VT(35,35,35)/1.5, Transparency = 0, Transparency2 = 1, CFrame = CF(pos), MoveToPos = nil, RotationX = MRANDOM(-15,15), RotationY = MRANDOM(-15,15), RotationZ = MRANDOM(-15,15), Material = "Neon", Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	for i =1,12 do
	WACKYEFFECT2({Time = 50, EffectType = "Box", Size = VT(1,1,.05), Size2 = VT(5,5,.05), Transparency = 0, Transparency2 = 1, CFrame = CF(pos), MoveToPos = pos+VT(MRANDOM(-28,28),MRANDOM(0,28),MRANDOM(-28,28)), RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Neon", Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
	for i = 1,2 do
	WACKYEFFECT2({Time = 60, EffectType = "Wave", Size = VT(10,.1,10), Size2 = VT(45,.1,45), Transparency = 0, Transparency2 = 1, CFrame = CF(pos), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-12,12), RotationZ = 0, Material = "Neon", Color =scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
	ApplyAoE(pos,20,0,0,75,true)
	lunc:Destroy()
	end))
	for i = 0,5 do
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(-33.2),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,-0.1)*ANGLES(RAD(0.4),RAD(7),RAD(-3.3)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,-0.1)*ANGLES(RAD(0.5),RAD(-7.5),RAD(3.8)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.3,0.5,0.2)*ANGLES(RAD(4.6),RAD(20.9),RAD(-12.6)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.3,0.3,-0.8)*ANGLES(RAD(87.1),RAD(0),RAD(-25.7)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(-0.1,0,0)*ANGLES(RAD(0),RAD(33.2),RAD(0))*NECKC0,Alpha)
	end
	for i = 0,15 do
		Swait()
			local Alpha = .2
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(-33.2),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,-0.1)*ANGLES(RAD(0.4),RAD(7),RAD(-3.3)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,-0.1)*ANGLES(RAD(0.5),RAD(-7.5),RAD(3.8)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.3,0.5,0.2)*ANGLES(RAD(4.6),RAD(20.9),RAD(-12.6)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.3,0.4,0.1)*ANGLES(RAD(87.1),RAD(0),RAD(108.4)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(-0.1,0,0)*ANGLES(RAD(0),RAD(33.2),RAD(0))*NECKC0,Alpha)
	end
	luneye.Parent = Character
	ATTACK = false
end

--keys
function MouseDown(Mouse)
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and ATTACK == false then
		lproj()
		-- Stuff for shoot
		idle = false
		attack = true
		pew = true
		shooting = true
		wait(1)
		pew = false
		attack = false
		idle = true
		shooting = false
	end
	if Key == "x" and ATTACK == false then
		arcs()
		-- Stuff for shoot
		idle = false
		attack = true
		pew = true
		shooting = true
		wait(1)
		pew = false
		attack = false
		idle = true
		shooting = false
	end

	if Key == "c" and ATTACK == false then
		
	end

	if Key == "v" and ATTACK == false then
		
	end

	if Key == "b" and ATTACK == false then
		
	end
	
	if Key=="2" then repeat Swait() Speed=35 spinspeed=3.6 until KEYHOLD==false Speed=16 spinspeed=1.8 end
	
	if Key=="m" then cs() end

	if Key == "]" and ATTACK == false then
		if sick.Parent ~= Character then
			sick = IT("Sound",Torso)
			sick.SoundId = "rbxassetid://"..SONG
		end
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end

--loop stuff

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

spinspeed = 1.8
loop = 0
loop2 = 0
loopval2 = 30
loopval = 90

while true do
	Swait()
	ANIMATE.Parent = nil
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	loop = loop + 1
	if loop >= loopval then
		loop = 0
	end
	SINE = SINE + CHANGE*2
	scol = Color3.fromRGB(33+33*COS(SINE/30),84,185-65*COS(SINE/30))
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
	local TiltVelocity = CF(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity/1.6))
	local WALKSPEEDVALUE = 14 / (Humanoid.WalkSpeed / 16)
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
			ra.C0 = Clerp(ra.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))), 1 / Animation_Speed)
			la.C0 = Clerp(la.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))), 1 / Animation_Speed)
			rh.C0 = Clerp(rh.C0, CF(.5, -0.4, -0.6) * ANGLES(RAD(1), RAD(0), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			lh.C0 = Clerp(lh.C0, CF(-.5, -1, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			ra.C0 = Clerp(ra.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))), 1 / Animation_Speed)
			la.C0 = Clerp(la.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))), 1 / Animation_Speed)
			rh.C0 = Clerp(rh.C0, CF(.5, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(0), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			lh.C0 = Clerp(lh.C0, CF(-.5, -0.8, -0.3) * ANGLES(RAD(-10), RAD(10), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		local Alpha = .1
		ANIM = "Idle"
		if ATTACK == false then
  		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,0+0.07*COS(SINE/42),0)*ANGLES(RAD(0+4.3*COS(SINE/42)),RAD(0),RAD(0))*ROOTC0,Alpha)
  		lh.C0 = lh.C0:lerp(CF(-0.5,-1-0.07*COS(SINE/42),-0.1)*ANGLES(RAD(0.4-4.3*COS(SINE/42)),RAD(7),RAD(-3.3)),Alpha)
  		rh.C0 = rh.C0:lerp(CF(0.5,-1-0.07*COS(SINE/42),-0.1)*ANGLES(RAD(0.5-4.3*COS(SINE/42)),RAD(-7.5),RAD(3.8)),Alpha)
  		la.C0 = la.C0:lerp(CF(-0.7,0.3-0.05*SIN(SINE/42),-0.8)*ANGLES(RAD(6.5+2*COS(SINE/56)),RAD(0.4-2*COS(SINE/65)),RAD(93.1+2*SIN(SINE/75))),Alpha)
  		ra.C0 = ra.C0:lerp(CF(0.8,0.2-0.05*SIN(SINE/42),-0.5)*ANGLES(RAD(-7.2+2*SIN(SINE/75)),RAD(-0.2+2*COS(SINE/56)),RAD(-88.1+2*COS(SINE/65))),Alpha)
  		Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0+3.6*SIN(SINE/42)),RAD(0),RAD(0)),Alpha)
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,0+0.08*SIN(SINE/WALKSPEEDVALUE*2),0-.10*COS(SINE/(WALKSPEEDVALUE/2)))*ANGLES(RAD(-2+3*SIN(SINE/(WALKSPEEDVALUE/2)))+RAD(TiltVelocity.Z)*1,RAD(10*COS(SINE/WALKSPEEDVALUE)),RAD(0))*ROOTC0,Alpha)
  		lh.C0 = lh.C0:lerp(CF(-0.5,-.9+0.55*COS(SINE/WALKSPEEDVALUE)/2,-.1-.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5+15*COS(SINE/WALKSPEEDVALUE))+RootPart.RotVelocity.Y/-75+SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.Z)*10,RAD(0-5*COS(SINE/WALKSPEEDVALUE)),RAD(0))*ANGLES(RAD(0-2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0+25*SIN(SINE/WALKSPEEDVALUE)*RAD(TiltVelocity.X)*5.5)),Alpha)
  		rh.C0 = rh.C0:lerp(CF(0.5,-.9-0.55*COS(SINE/WALKSPEEDVALUE)/2,-.1+.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5-15*COS(SINE/WALKSPEEDVALUE))-RootPart.RotVelocity.Y/75+-SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.Z)*10,RAD(0-5*COS(SINE/WALKSPEEDVALUE)),RAD(0))*ANGLES(RAD(0+2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0+25*SIN(SINE/WALKSPEEDVALUE)*-RAD(TiltVelocity.X)*5.5)),Alpha)
  		la.C0 = la.C0:lerp(CF(-1.5,0.5,0)*ANGLES(RAD(-28*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
  		ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(28*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
  		Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0)*ANGLES(RAD(0+3.5*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(-10*COS(SINE/WALKSPEEDVALUE))-RAD(TiltVelocity.X)*3),Alpha)
		end
	end
	lunw2.C0 = lunw2.C0:lerp(CF(.5*SIN(SINE/70),0-.5*COS(SINE/35),0)*ANGLES(0,0,RAD(SINE*spinspeed)),.1)
	for y,b in pairs(luneye:GetChildren()) do if b.Name=="cs" then b.Color=Color3.fromRGB(33+33*COS(SINE/30),84,185-65*COS(SINE/30)) end end
	local pos = CF(HITPOS)*ANGLES(RAD(0),RAD(0),RAD(0))*CF(MRANDOM(-8,8),0,MRANDOM(-8,8)).p
	local sfl,spos = Raycast(pos+VT(0,1,0), (CF(pos, pos + VT(0, -1, 0))).lookVector, 50, Character)
	if MRANDOM(1,4)==1 then	
	WACKYEFFECT2({Time = 15, EffectType = "Sphere", Size = VT(.15,4,.15), Size2 = VT(.2,.1,.2), Transparency = 0, Transparency2 = 1, CFrame = CF(spos)*CF(0,12,0)*ANGLES(0,0,RAD(MRANDOM(-10,10))), MoveToPos = spos-VT(0,4,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
	if loop == 1 then
	WACKYEFFECT2({Time = 45, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(14,.05,14), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.9,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 5})
	WACKYEFFECT2({Time = 50, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(25,.15,1.5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.9,0)*ANGLES(0,RAD(-45),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 2, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 5})
	WACKYEFFECT2({Time = 50, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(25,.15,1.5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.9,0)*ANGLES(0,RAD(45),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 2, RotationZ = 0, Material = "Neon",ColorLoop = true, Color = scol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 5})
	end
	if ATTACK == false then lunw.C1 = lunw.C1:lerp(d,.1) end
	unanchor()
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.SoundId = "rbxassetid://"..SONG
	sick.Looped = true
	sick.Pitch = 1
	sick.Volume = 3
	sick.Playing = true
end
